import base64
import json
import logging
import os
import traceback
import uuid
from io import BytesIO, StringIO

import boto3
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# Set up logger
logger = logging.getLogger()
logger.setLevel(logging.INFO)

def lambda_handler(event, context):
    """
    Execute Python code generated by LLM and return the results
    
    Args:
        event: Event containing Python code generated by LLM
        context: Lambda context
        
    Returns:
        Execution results in JSON string format
    """
    try:
        logger.info("Lambda execution started")
        
        # Get Python code from event - only process Bedrock Flow format
        python_code = None
        user_query = None
        for input_item in event['node']['inputs']:
            if input_item.get('name') == 'codeHookInput':
                content = input_item.get('value', '')
                # Extract user query and code separately
                if 'User Query' in content:
                    parts = content.split('```python')
                    user_query = parts[0].replace('User Query:', '').strip()
                    python_code = parts[1].replace('```python', '').replace('```', '').strip()
                else:
                    python_code = content.replace('```python', '').replace('```', '').strip()
                break
        
        if not python_code:
            logger.info("No Python code provided in the request")
            return json.dumps({
                'statusCode': 400,
                'body': 'No Python code provided'
            })
    
        # Generate unique execution ID
        execution_id = str(uuid.uuid4())
        logger.info(f"Starting execution with ID: {execution_id}")
        
        # Create a secure execution environment
        local_vars = {
            'boto3': boto3,
            'os': os,
            'BytesIO': BytesIO,
            'StringIO': StringIO,
            'json': json,
            'base64': base64,
            'execution_id': execution_id,
            'logger': logger,
            'pd': pd,
            'plt': plt,
            'sns': sns,
            'np': np
        }
        
        # Execute modified code
        logger.info("Starting Python code execution")
        # Modify code to capture return value
        modified_code = python_code + "\n\n# Execute lambda_handler and capture result\nresult = lambda_handler({'query': 'execute analysis'}, None)"
        exec(modified_code, globals(), local_vars)
        logger.info("Python code execution completed successfully")
        
        # Get execution result and add user query
        result = local_vars.get('result', {})
        if isinstance(result, dict):
            result['userQuery'] = user_query
            
            # Remove duplicate body if it matches imageUri
            if 'body' in result and 'imageUri' in result and result['body'] == result['imageUri']:
                del result['body']
                
        logger.info(f"Execution result: {result}")
        
        # Convert result to JSON string and return
        logger.info("Lambda execution completed successfully")
        return json.dumps(result, ensure_ascii=False)
        
    except Exception as e:
        error_msg = f"Error executing Python code: {str(e)}"
        logger.error(f"Execution failed: {error_msg}")
        logger.error(traceback.format_exc())
        
        return json.dumps({
            'statusCode': 500,
            'body': error_msg
        }) 